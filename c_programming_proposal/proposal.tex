\documentclass[a4paper,12pt]{report}
\usepackage{color}
\usepackage{listings}
\usepackage{fullpage}
\usepackage[none]{hyphenat} 

\lstset{ %
language=C,                % choose the language of the code
basicstyle=\tiny,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\tiny,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
numbersep=4pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,           % adds a frame around the code
tabsize=4,          % sets default tabsize to 2 spaces
captionpos=b,           % sets the caption-position to bottom
breaklines=true,        % sets automatic line breaking
breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
escapeinside={\%}{)}          % if you want to add a comment within your code
}


\begin{document}

\section*{Proposed Class}
C Programming

\section*{Requirements}
COSC 311

\section*{Why We Need This Class}
Current computer science curriculum programming classes are based around high-level object orientated programming.  Many students are not required to use a low-level non-object-oriented programming language such as C and are unprepared when the need presents itself.  Our curriculum focuses on languages like Java and Python which do not require students to handle important concepts such as memory management, memory pooling, mixing assembly with other languages, build tools, and pointer arithmetic.  A class is needed to help fill this void within our curriculum.

\section*{Class Purpose}
The purpose of this class is to introduce students to C programming concepts, tools, libraries, and the importance of C in the realm of computers and computer science.  Students will be able to read and develop C programs, understand how to use and implement libraries, have an understanding of program and memory structure, have the ability to implement common data structures and an understanding of pointer arithmetic.  Three large projects will be used to teach C programming semantics and constructs in a non-object-oriented environment while targeting common C programming problems.  Focus will be placed on efficient and reusable code, while fostering a deeper understanding of program memory and instruction flow.  

\section*{Target Students}
Students capable of implementing common data structures and algorithms in other languages but want to learn or get practice in C and low-level programming.  Many students in the department ask me for advice and tutoring in C and C++; several have expressed interest in a class such as the one I am proposing.  I wish to make this class available to undergraduate and graduate students.

\section*{What I Want To Get Out Of This Class}
I want to continue to build my experience and knowledge at teaching others concepts and applications in computer science.  I have been programming in C over the last seven years, and I want to pass on that knowledge to others so that they have a more rounded education and experience in real-world tools. 


\section*{Grading}
Grades are based on three categories

\begin{tabular}{l l}
60\% & C projects \\
20\% & Lab Assignments \\
20\% & Final 
\end{tabular}

\section*{Textbook}
An excellent textbook on C programing was selected for this class.  The book covers most of the major topics that will be covered.  The book can be accessed for free by students on the Books 24x7 database.

\begin{tabular}{l}
C Programming \\
Salim Y. Amdani \\
Laxmi Publications \copyright 2009 (414 pages) \\
ISBN:9788131805466 \\
\end{tabular}

\section*{Lab Assignments}
Lab assignments are given at the start of each week and are due Friday at midnight via e-mail.  Lab assignments are small projects based on weekly lecture topics.  Lab assignments are worth 10pts each.  Assignments lose 1pt each week they are late and must be turned in no later then the last day of class.

\section*{Projects}
Four large projects will be assigned during the semester. These projects can be worked on alone or in pairs.  These projects combine the skills taught in class and practiced in lab assignments.  Projects will be due two weeks after they are given.  Late projects will lose 5pts each week they are late and must be turned in no later then the last day of class.

\subsubsection*{Groups}
Students can work in groups of two or three on larger projects, but each member of a group must turn in a minimum one page write up of their contribution to the project.

\subsubsection*{Graduate Students}
Graduate students are expected to complete all optional problems.

\section*{Class Topics Plan}
List of topics and assignments planned for each week.

\subsection*{Week 1}
\subsubsection*{ Readings }
Chapter 1
\subsubsection*{Lecture Topics}
\begin{itemize}
\item History of C
\item Why is C important
\item GCC
\item Makefiles
\item CMake
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Hello World - Makefile
\item Good-Bye World - CMake
\end{itemize}

\subsection*{Week 2}
\subsubsection*{ Readings }
Chapter 3, 4, 5
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Data Types 
\item Constructs
\item Functions
\item Storage Class
\item Intro stdlib
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item print sizeof C types
\item Conditional Constructs
\item Looping
\item Basic functions
\item Pass by value
\item Recursion
\end{itemize}

\subsection*{Week 3}
\subsubsection*{ Readings }
Chapter 6
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Macros
\item Header Files
\item Problems with data types
\item assert, enforce, and C errors
\item static arrays
\item stdlib
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Write stdtype.h ( U32, I32, ect... )
\item Write error.h ( assert, enforce, ... )
\item Arrays( reading, writing, sorting )
\end{itemize}

\subsection*{Week 4}
\subsubsection*{ Readings }
Chapter 7
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Intro to pointers
\item Passing Pointers
\item malloc, calloc, realloc, free
\item Dynamic arrays
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Functions that take pointers
\item Dynamic Memory ( primitives, arrays )
\item Using malloc, calloc, realloc, and free
\end{itemize}

\subsection*{Week 5}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Intro to Strings
\item String Conversions
\item Pointer Arithmetic 
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Reading and writing strings
\item Strings ( Searching, sorting, case issues ) string.h
\item Strings( Searching, sorting ) pointer arithmetic
\end{itemize}

\subsection*{Week 6}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Libraries
\item Unit testing 
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Start String Library Project 
\end{itemize}

\subsection*{Week 7}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Memory Leaks
\item Dangling Pointers 
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item String Library Project Due
\end{itemize}

\subsection*{Week 8}
\subsubsection*{ Readings }
Chapter 8
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Structures
\item Unions
\item Anonymous Structures and Unions
\item Stacks
\item Linked Lists
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Basic Struct and unions usage
\item Convert infix to postfix 
\end{itemize}

\subsection*{Week 9}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Timing code
\item Memory Management
\item Memory Pools
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Start Memory Pool Library Project
\end{itemize}

\subsection*{Week 10}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Using Assembly with C
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Memory Pool Library Project Due
\end{itemize}

\subsection*{Week 11}
\subsubsection*{ Readings }
Chapter 9
\subsubsection*{Lecture Topics}
\begin{itemize}
\item File I/O - Text Files
\item String Parsing with C
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Start INI Reader Library Project
\end{itemize}

\subsection*{Week 12}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item File I/O - Binary Files
\item Function Pointers
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item INI Reader Project Due
\end{itemize}

\subsection*{Week 13}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Command line arguments
\item Scanning Directories and Files
\item File Stats
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item Start File Packer Project
\end{itemize}

\subsection*{Week 14}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item GUI - FLTK
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item File Packer Project Due
\end{itemize}


\subsection*{Week 15}
\subsubsection*{Lecture Topics}
\begin{itemize}
\item Review for final 
\end{itemize}
\subsubsection*{Assignment}
\begin{itemize}
\item All Projects and Assignments are due
\end{itemize}



\pagebreak
\section*{Strings Library Project}
Implement the following functions to work like the C standard library functions  Each function should have its own header file and C source file.  The header file should be well documented as to the functions purpose, input parameters, and output values.  Each function should have a unit test.  You need to use CMake to make a library and a unit test binary that runs each functions unit test and reports each unit tests result.

\subsection*{Functions To Implement}
\begin{lstlisting}
void * _memset( void *, I32, size_t );
void * _memcpy( void *, void *, size_t );
size_t _strlen( char * );
char * _strcat( char *, char * );
char * _strncat( char *, char * );
char * _strcpy( char *, char * );
char * _strncpy( char *, char * );
char * _strdup( char * );
char * _strndup( char * );
I32 _strcmp( char *, char * );
I32 _stricmp( char *, char * );
char * _substr( char *, size_t );
char * _trim( char * );
char * _strchr( char *, char );
char * _strrchr( char *, char );
I32 _atoi( char * );
char * _itoa( char *, I32 );
char * _strtok( char *, char * );
char * _strhex( char *dest, const I32 val ); //  write val as a hex string in dest
char * _strbin( char *dest, const I32 val ); //  write val as a binary string in dest
\end{lstlisting}

\subsection*{Optional Functions}
\begin{lstlisting}
F32 _atof( char * );
char * _ftoa( char *, F32 );
char * _strstr( char *, char * );
char * _strfry( char * ); 
void * _memmove( void *, void *, size_t );
\end{lstlisting}

\pagebreak
\section*{Memory Pool Library Project}
Develop a library to create a stack based memory pool.  The memory pool will be used in a time critical application that requires dynamic chunks of memory to be created and maintained during the algorithm.  There will be one structure, the memory pool, and four functions.

\subsection*{API}
\begin{lstlisting}
struct MemoryPool // holds info about a memory pool

/*
    Creates a memory pool of size pool_size.  If pool is NULL,
    this function will return a pointer to a New MemoryPool, 
    else returns pool;

    Example Usage:
    // create a 10K pool
    MemoryPool *pool = PoolCreate( NULL, 10240 ); 

*/
MemoryPool * PoolCreate( MemoryPool *pool, size_t pool_size );

/*
    Grab memory from a pool.  Returns NULL if pool is out of 
    memory.

    Example Usage:
    // get 1024 bytes from the pool
    char *str = (char *)PoolMalloc( pool, 1024 ); 

*/
void * PoolMalloc( MemoryPool *pool, size_t block_size );

/*
   Releases all of the memory in the pool to be reused.
   Watch out for dangeling pointers!
*/
void PoolRelease( MemoryPool *pool );

/*
   Frees the memory pool back to the operating system.
   Pool is nolonger usable.

*/
void PoolFree( MemoryPool *pool );
\end{lstlisting}

\subsection*{Optional Functions}
Implement the two-sided memory pool or the long/short term two sided memory pool.

For two-side memory pool:
\begin{lstlisting}
// Replace PoolRelease with PoolSwap
void PoolSwap( MemoryPool * pool );
\end{lstlisting}

For long/short term two-side memory pool:
\begin{lstlisting}
// Add parameter to PoolMalloc
void * PoolMalloc( MemoryPool * pool, size_t block_size, int long_term );

// Add parameter to PoolRelease
void Poolrelease( MemoryPool *pool, int long_term );
\end{lstlisting}



\pagebreak
\section*{INI Reader Project}
Develop a library that reads in a standard INI configuration file into memory, implement the give API functions to query the INI file, add new entries, and update entries.  Each function should have its own header file and C source file.  Each header file should be well documented as to its purpose, input parameters, and output values.  You need to use CMake to produce a library and a unit test program that tests each function in the API.

\subsection*{API}
\begin{lstlisting}
struct Config // memeory struct to load the INI file into
I32 ConfigOpen( Config *, char * ); // read a file into memory
I32 ConfigClear( Config * );  // clear an config structs memory, no memory leaks!
char * ConfigGetString( Config *, char *, char * ); // get a string value from the config settings
I32 ConfigGetInt( Config *, char *, I32 ); // get an int value from the config settings
F32 ConfigGetFloat( Config *, char *, F32 ); // get a float value from the config settings
char * ConfigSetString( Config *, char *, char * ); // set or add a string
I32 ConfigSetInt( Config *, char *, I32 ); // set or add an int
F32 ConfigSetFloat( Config *, char *, F32 ); // set or add a float
\end{lstlisting}

\subsection*{Optional Functions}
\begin{lstlisting}
I32 ConfigSave( Config *, char * ); // save a config struct to a INI file
\end{lstlisting}

\pagebreak
\section*{File Packer Project}
Develop a file and directory packing utility.  This program will pack one or more files and/or directories into a single file or unpack a file rebuilding the packed file structure.  This program is controlled via command line arguments.

The program takes the following arguments.
\begin{lstlisting}
pack -p [DIRECTORY TO PACK] [NAME OF PACK FILE]
pack -u [PACK FILE]
pack -h
\end{lstlisting}

\subsection*{Optional Arguments}
\begin{lstlisting}
pack -l [PACK FILE]
pack -a [PACK FILE] [FILE/DIR TO ADD TO PACK]
pack -d [PACK FILE] [FILE/DIR TO DELETE FROM PACK]
\end{lstlisting}

\end{document}

