\section{Z-Buffering}

Computer graphics used in modern games and simulation environments that require real time updates to its environment are based around the z-buffering algorithm.  Z-buffering builds a scene by computing the depth of triangles in a scene from a view-point,  known as the eye.  The algorithm is simple and each pixel can be computed with stream processors that are commonly  used on modern GPUs.  Hardware implementations of z-buffers commonly have two frame buffers for color and a depth buffer.    The color buffer is split into the front buffer and the back buffer.  The back buffer is where the algorithm is rendering to, and the front buffer is drawn to the screen.  Once the back buffer is filled it is swapped with the front buffer,  -- normally done with a simple pointer swap.  The algorithm for z-buffer is as follows \cite{fast:2008}:

\begin{algorithm}
\begin{algorithmic}[1]
\STATE $C[ ] \gets \textit{background color}$ 
\STATE $Z[ ] \gets \infty$
\FOR{ all \textit{N} triangles }
	\FOR{ each pixel p in triangle }
		\STATE $c \gets \textit{new color}$
		\STATE $z \gets \textit{new depth}$
		\IF{ $z < Z_{p} $ }
			\STATE $Z_{p} \gets z$
			\STATE $C_{p} \gets c$
		\ENDIF
	\ENDFOR
\ENDFOR
\end{algorithmic}
\caption{Example of the z-buffer algorithm}
\label{z-buffer}
\end{algorithm}

This algorithm works by tracking the color depth for each given pixel rendered in the back buffer.  This algorithm is fast and easy to implement.  However light, shadow, reflection, or refraction are not calculated.   Z-buffering only renders from a single point, the eye, but to calculate shadow or reflection the algorithm needs to be able to work from any point in space.  Ray casting is often used to produce these effects.  The solution relies on building a better physics-based model for light.
